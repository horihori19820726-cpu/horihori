<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport"
  content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>Retro Tetris â€“ Mobile NEXT</title>

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
html,body{
  margin:0;padding:0;height:100%;
  background:#000;overflow:hidden;
}
body{
  color:#0ff;
  font-family:'Press Start 2P', monospace;
  touch-action:none;
}

/* ===== ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ ===== */
.app{
  display:flex;
  flex-direction:column;
  align-items:center;
  height:100vh;
}

/* NEXTã‚¨ãƒªã‚¢ */
.next-wrap{
  margin-top:6px;
  text-align:center;
  font-size:10px;
}
canvas.next{
  background:#000;
  border:2px solid #0ff;
  margin-top:4px;
}

/* ã‚²ãƒ¼ãƒ  */
.game{
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
}
canvas#game{
  background:#000;
  border:3px solid #0ff;
}
</style>
</head>

<body>

<div class="app">
  <!-- NEXT -->
  <div class="next-wrap">
    NEXT
    <canvas class="next" id="next" width="96" height="96"></canvas>
  </div>

  <!-- GAME -->
  <div class="game">
    <canvas id="game"></canvas>
  </div>
</div>

<script>
/* =====================
   ðŸ”Š SOUND
===================== */
const sounds={
  bgm:new Audio("bgm.mp3"),
  move:new Audio("se_move.wav"),
  rotate:new Audio("se_rotate.wav"),
  drop:new Audio("se_drop.wav"),
  line:new Audio("se_line.wav"),
  gameover:new Audio("se_gameover.wav")
};
sounds.bgm.loop=true;
sounds.bgm.volume=0.4;

let audioUnlocked=false;
function unlockAudio(){
  if(audioUnlocked) return;
  audioUnlocked=true;
  sounds.bgm.play().catch(()=>{});
}
window.addEventListener("pointerdown",unlockAudio,{once:true});

function playSE(name){
  const a=sounds[name];
  if(!a) return;
  const c=a.cloneNode();
  c.play().catch(()=>{});
}

/* =====================
   GAME CORE
===================== */
const COLS=10,ROWS=20;
let BLOCK=24;

const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const nextCanvas=document.getElementById("next");
const nctx=nextCanvas.getContext("2d");

function resize(){
  BLOCK=Math.floor(Math.min(window.innerWidth/12, window.innerHeight/22));
  canvas.width=COLS*BLOCK;
  canvas.height=ROWS*BLOCK;
}
window.addEventListener("resize",resize);
resize();

const COLORS={I:"#0ff",O:"#ff0",T:"#a0f",S:"#0f0",Z:"#f00",J:"#00f",L:"#fa0"};
const PIECES=[
 {k:"I",s:[[1,1,1,1]]},{k:"O",s:[[1,1],[1,1]]},
 {k:"T",s:[[0,1,0],[1,1,1]]},{k:"S",s:[[0,1,1],[1,1,0]]},
 {k:"Z",s:[[1,1,0],[0,1,1]]},{k:"J",s:[[1,0,0],[1,1,1]]},
 {k:"L",s:[[0,0,1],[1,1,1]]}
];

let board,current,next;
let dropCounter=0,lastTime=0;

/* ===== åˆæœŸåŒ– ===== */
function reset(){
  board=Array.from({length:ROWS},()=>Array(COLS).fill(null));
  current=randomPiece();
  next=randomPiece();
}
function randomPiece(){
  const p=PIECES[Math.random()*PIECES.length|0];
  return{m:p.s.map(r=>r.slice()),c:COLORS[p.k],x:3,y:0};
}

/* ===== ãƒ­ã‚¸ãƒƒã‚¯ ===== */
function collide(px,py,m){
  for(let y=0;y<m.length;y++)
  for(let x=0;x<m[y].length;x++)
    if(m[y][x]){
      const nx=px+x,ny=py+y;
      if(nx<0||nx>=COLS||ny>=ROWS||board[ny]?.[nx]) return true;
    }
  return false;
}
function merge(){
  current.m.forEach((r,y)=>r.forEach((v,x)=>{
    if(v) board[current.y+y][current.x+x]=current.c;
  }));
}
function clearLines(){
  let c=0;
  board=board.filter(r=>r.some(v=>!v)||(++c&&false));
  while(board.length<ROWS) board.unshift(Array(COLS).fill(null));
  if(c) playSE("line");
}
function spawnNext(){
  current=next;
  current.x=3;
  current.y=0;
  next=randomPiece();
}
function drop(){
  if(!collide(current.x,current.y+1,current.m)) current.y++;
  else{
    merge(); playSE("drop");
    clearLines();
    spawnNext();
  }
}
function rotate(){
  const r=current.m[0].map((_,i)=>current.m.map(row=>row[i]).reverse());
  if(!collide(current.x,current.y,r)){
    current.m=r; playSE("rotate");
  }
}

/* ===== æç”» ===== */
function drawCell(ctx,x,y,c,s){
  ctx.fillStyle=c;
  ctx.fillRect(x*s,y*s,s,s);
  ctx.strokeStyle="#000";
  ctx.lineWidth=2;
  ctx.strokeRect(x*s,y*s,s,s);
}
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  board.forEach((r,y)=>r.forEach((c,x)=>c&&drawCell(ctx,x,y,c,BLOCK)));
  current.m.forEach((r,y)=>r.forEach((v,x)=>v&&drawCell(ctx,current.x+x,current.y+y,current.c,BLOCK)));

  // NEXT
  nctx.clearRect(0,0,96,96);
  next.m.forEach((r,y)=>r.forEach((v,x)=>v&&drawCell(nctx,x+1,y+1,next.c,20)));
}

/* ===== LOOP ===== */
function update(t=0){
  const d=t-lastTime; lastTime=t;
  dropCounter+=d;
  if(dropCounter>600){
    dropCounter=0;
    drop();
  }
  draw();
  requestAnimationFrame(update);
}

/* =====================
   ðŸ“± TOUCH CONTROL
===================== */
let sx=0,sy=0,lastTap=0;
canvas.addEventListener("touchstart",e=>{
  const t=e.touches[0];
  sx=t.clientX; sy=t.clientY;
},{passive:false});

canvas.addEventListener("touchend",e=>{
  const dx=e.changedTouches[0].clientX-sx;
  const dy=e.changedTouches[0].clientY-sy;
  const now=Date.now();

  if(Math.abs(dx)<10 && Math.abs(dy)<10){
    if(now-lastTap<300){
      while(!collide(current.x,current.y+1,current.m)) current.y++;
      playSE("drop");
    }else{
      if(sx<canvas.width/2 && !collide(current.x-1,current.y,current.m)) current.x--,playSE("move");
      if(sx>=canvas.width/2 && !collide(current.x+1,current.y,current.m)) current.x++,playSE("move");
    }
    lastTap=now;
    return;
  }

  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>0 && !collide(current.x+1,current.y,current.m)) current.x++,playSE("move");
    if(dx<0 && !collide(current.x-1,current.y,current.m)) current.x--,playSE("move");
  }else{
    if(dy>0) drop();
    if(dy<0) rotate();
  }
},{passive:false});

/* START */
reset();
requestAnimationFrame(update);
</script>
</body>
</html>
